# Day22 POI搜刮系统实现方案

> 本文档讲解实现原理，不包含具体代码

---

## 一、整体架构

```
用户点击"开始探索"
       ↓
┌──────────────────┐
│  POISearchManager │ ← 负责搜索附近真实地点
└────────┬─────────┘
         ↓
┌──────────────────┐
│ ExplorationManager│ ← 管理POI列表 + 地理围栏
└────────┬─────────┘
         ↓
┌──────────────────┐
│   MapTabView     │ ← 显示POI标记
└────────┬─────────┘
         ↓
    用户走到POI附近
         ↓
┌──────────────────┐
│ POIProximityPopup │ ← 弹出搜刮提示
└────────┬─────────┘
         ↓
┌──────────────────┐
│ ScavengeResultView│ ← 显示搜刮结果
└────────┬─────────┘
         ↓
┌──────────────────┐
│ InventoryManager │ ← 物品存入背包
└──────────────────┘
```

### 组件职责

| 组件 | 职责 |
|-----|------|
| POISearchManager | 调用MapKit搜索附近真实地点 |
| ExplorationManager | 管理探索状态、POI列表、地理围栏 |
| MapTabView | 地图界面，显示POI标记 |
| POIProximityPopup | 接近POI时的弹窗提示 |
| ScavengeResultView | 搜刮结果展示界面 |
| InventoryManager | 物品存入背包（已有） |

---

## 二、POI搜索原理

### 2.1 使用的技术

Apple的MapKit框架提供了`MKLocalSearch`，可以搜索真实世界的地点。这是苹果地图背后的数据，包含了全球各地的商店、医院、餐厅等真实地点信息。

### 2.2 工作原理

```
创建搜索请求
    ↓
指定搜索参数：
  - 中心点（用户当前位置）
  - 范围（1公里半径）
  - 类型（超市、医院等）
    ↓
MapKit向Apple服务器发送请求
    ↓
返回结果列表，每个结果包含：
  - 地点名称（如"沃尔玛超市"）
  - 地点坐标（经纬度）
  - 地点类型
```

### 2.3 POI类型映射

Apple的POI类型需要映射成游戏中的显示：

| Apple类型 | 游戏显示 | 图标 |
|----------|---------|------|
| .store | 商店 | 🏪 |
| .hospital | 医院 | 🏥 |
| .pharmacy | 药店 | 💊 |
| .gasStation | 加油站 | ⛽ |
| .restaurant | 餐厅 | 🍽️ |
| .cafe | 咖啡店 | ☕ |

### 2.4 为什么搜索多种类型？

单一类型搜索可能返回结果太少。比如用户在住宅区，附近可能没有医院。

我们的策略是搜索多种类型，合并结果，确保玩家总能找到可探索的地点。

### 2.5 搜索时机

**关键决策**：什么时候搜索POI？

我们选择在**用户点击"开始探索"时**搜索，原因：

| 方案 | 优点 | 缺点 |
|-----|------|------|
| 开始探索时搜索 ✅ | 数据最新 | 需要等待加载 |
| 打开地图时搜索 | 提前准备 | 可能白加载 |
| 定时刷新 | 减少请求 | 不够及时 |

---

## 三、地图显示POI标记原理

### 3.1 使用的技术

SwiftUI的`Map`组件配合`Annotation`来显示自定义标记。

### 3.2 工作原理

```
POI搜索完成
    ↓
POI列表存储在ExplorationManager中
    ↓
MapTabView观察这个列表（@Published）
    ↓
列表变化时，自动更新地图上的标记
    ↓
每个POI显示为一个Annotation：
  - 位置：POI的经纬度
  - 图标：根据类型显示
```

### 3.3 Annotation的组成

每个POI标记需要：

| 属性 | 说明 |
|-----|------|
| coordinate | 经纬度坐标，决定标记位置 |
| title | POI名称，如"沃尔玛超市" |
| icon | 根据类型显示的图标 |

### 3.4 标记的生命周期

```
开始探索 → 显示所有POI标记
    ↓
探索进行中 → 标记保持不变
    ↓
搜刮某个POI → 该标记可变灰（可选）
    ↓
停止探索 → 清除所有标记
```

### 3.5 为什么探索中不刷新POI？

一旦开始探索，POI列表就固定了，原因：

1. **体验一致**：避免走着走着POI突然消失
2. **围栏已设置**：地理围栏在开始时就创建好了
3. **简化逻辑**：减少状态同步的复杂度

如果玩家想刷新POI，需要：**停止探索 → 重新开始探索**

---

## 四、地理围栏原理

### 4.1 什么是地理围栏？

地理围栏（Geofence）是一个虚拟的地理边界。当设备进入或离开这个边界时，系统会自动触发通知。

想象在每个POI周围画一个50米半径的圆圈，当玩家走进这个圆圈时，系统就知道了。

### 4.2 使用的技术

CoreLocation框架的`CLLocationManager`支持地理围栏监控。

### 4.3 围栏的定义

每个地理围栏需要指定：

| 参数 | 说明 | 我们的设置 |
|-----|------|-----------|
| 圆心坐标 | 围栏中心位置 | POI的经纬度 |
| 半径 | 触发范围 | 50米 |
| 标识符 | 唯一ID | POI的唯一标识 |

### 4.4 工作原理

```
开始探索
    ↓
为每个POI创建一个CLCircularRegion（圆形围栏）
    ↓
调用locationManager.startMonitoring(for: region)
    ↓
系统在后台持续监控
    ↓
用户进入围栏范围
    ↓
系统调用delegate方法：locationManager(_:didEnterRegion:)
    ↓
我们在回调中弹出搜刮提示
```

### 4.5 为什么用地理围栏而不是手动计算距离？

| 方式 | 优点 | 缺点 |
|-----|------|------|
| 手动计算距离 | 完全控制、无数量限制 | 耗电、需要频繁获取位置 |
| 系统地理围栏 | 系统级优化、省电、后台工作 | 最多20个围栏 |

我们选择系统围栏，因为：
- 系统做了大量优化，省电
- 即使App在后台也能触发
- 20个围栏对于Day22简化版足够

### 4.6 围栏数量限制

iOS限制每个App最多同时监控**20个地理围栏**。

对于Day22的简化版本，我们显示的POI数量不会超过这个限制。

后续如果需要更多POI，可以考虑：
- 只为最近的N个POI创建围栏
- 动态管理围栏（走远了就删除，接近新的就创建）

### 4.7 围栏触发时机

CLLocationManager支持两种触发：

| 事件 | 说明 | 我们是否使用 |
|-----|------|-------------|
| didEnterRegion | 进入围栏时 | ✅ 使用 |
| didExitRegion | 离开围栏时 | ❌ 暂不使用 |

我们只关心"进入"事件，用于触发搜刮提示。

---

## 五、搜刮弹窗原理

### 5.1 触发时机

当CLLocationManager检测到用户进入某个POI的地理围栏时，触发弹窗显示。

### 5.2 弹窗内容设计

```
┌─────────────────────────────────┐
│  🏪 发现废墟：XXX超市            │
│  距离: 32米                      │
├─────────────────────────────────┤
│  [ 立即搜刮 ]  [ 稍后再说 ]      │
└─────────────────────────────────┘
```

弹窗需要显示：
- POI类型图标
- POI名称
- 当前距离（可选）
- 两个操作按钮

### 5.3 两个按钮的作用

| 按钮 | 点击后的行为 |
|-----|-------------|
| 立即搜刮 | 触发物资生成 → 显示结果 → 物品存入背包 |
| 稍后再说 | 关闭弹窗 → 继续探索 → 以后可以再回来 |

### 5.4 状态管理

使用ExplorationManager中的状态变量控制弹窗：

| 状态变量 | 类型 | 作用 |
|---------|------|------|
| showPOIPopup | Bool | 控制弹窗是否显示 |
| currentPOI | POI? | 当前接近的POI信息 |

当进入围栏时：
1. 设置`currentPOI`为触发的POI
2. 设置`showPOIPopup = true`
3. 弹窗自动显示

### 5.5 弹窗的呈现方式

使用SwiftUI的`.sheet`或`.overlay`来呈现弹窗，覆盖在地图上方。

---

## 六、随机生成物资原理

### 6.1 物品来源

复用已有的物品定义系统：

```
Supabase数据库
    ↓
item_definitions表
    ↓
InventoryManager.loadItemDefinitions()
    ↓
InventoryManager.itemDefinitions（内存中的物品池）
```

### 6.2 生成逻辑

```
用户点击"立即搜刮"
    ↓
随机决定物品数量（1-3件）
    ↓
对于每件物品：
  - 从物品池随机抽取一个
  - 随机决定数量（1-3个）
    ↓
返回生成的物品列表
```

### 6.3 Day22简化版 vs 后续版本

| 方面 | Day22简化版 | 后续完整版 |
|-----|------------|-----------|
| 物品池 | 所有POI共用一个池 | 根据POI类型使用不同池 |
| 物品类型 | 完全随机 | 超市给食物、医院给药品 |
| 数量 | 固定1-3件 | 可根据POI规模调整 |

### 6.4 后续可扩展的类型关联

| POI类型 | 专属物品池 |
|--------|-----------|
| 超市/便利店 | 食物、饮料、零食 |
| 医院/诊所 | 药品、绷带、急救包 |
| 药店 | 止痛药、消炎药 |
| 加油站 | 燃料、工具、电池 |
| 餐厅 | 食物、饮品 |

---

## 七、搜刮结果展示原理

### 7.1 展示时机

物资生成完成后，立即显示结果界面。

### 7.2 界面设计

```
┌─────────────────────────────────┐
│  🎉 搜刮成功！                   │
│  📍 XXX超市                      │
├─────────────────────────────────┤
│  获得物品：                      │
│  • 矿泉水 x2                     │
│  • 罐头 x1                       │
│  • 绷带 x1                       │
├─────────────────────────────────┤
│        [ 确认 ]                  │
└─────────────────────────────────┘
```

### 7.3 显示内容

| 内容 | 说明 |
|-----|------|
| POI名称 | 显示刚才搜刮的地点 |
| 物品列表 | 显示每个物品的图标、名称、数量 |
| 确认按钮 | 关闭结果界面 |

### 7.4 动画效果（可选）

为了增加获得感，可以添加：
- 物品依次出现的动画
- 物品图标的弹跳效果
- 背景的闪光效果

Day22可以先不做动画，确保核心功能完成。

### 7.5 确认后的行为

用户点击确认后：
1. 关闭结果视图
2. 返回地图界面
3. 继续探索
4. 该POI标记可以变灰（可选，表示已搜刮）

---

## 八、物品存入背包原理

### 8.1 复用已有系统

Day21已经实现了完整的背包系统，我们直接复用：

```
InventoryManager.shared.addItem(itemId, quantity)
```

### 8.2 存储流程

```
生成物品列表
    ↓
遍历每个物品
    ↓
调用addItem()
    ↓
InventoryManager更新本地数据
    ↓
同步到Supabase数据库
    ↓
背包页面自动刷新显示
```

### 8.3 与行走奖励的关系

| 奖励来源 | 触发时机 | 存入方式 |
|---------|---------|---------|
| 行走奖励 | 停止探索时 | addItem() |
| POI搜刮 | 搜刮时 | addItem() |

两者使用相同的背包系统，物品会合并显示。

---

## 九、完整数据流

### 9.1 开始探索流程

```
1. 用户点击"开始探索"
       ↓
2. 检查并加载物品定义（如果还没加载）
       ↓
3. 获取用户当前位置
       ↓
4. POISearchManager搜索1公里内的真实POI
       ↓
5. 将POI列表存入ExplorationManager
       ↓
6. 为每个POI创建50米地理围栏
       ↓
7. MapTabView显示POI标记
       ↓
8. 开始记录行走距离
       ↓
探索正式开始
```

### 9.2 进入POI范围流程

```
1. 用户走动，系统持续监控位置
       ↓
2. 进入某POI的50米范围
       ↓
3. 系统触发didEnterRegion回调
       ↓
4. 通过region.identifier找到对应的POI
       ↓
5. 设置currentPOI和showPOIPopup
       ↓
6. 弹窗显示
```

### 9.3 搜刮流程

```
1. 用户点击"立即搜刮"
       ↓
2. 从物品池随机生成1-3件物品
       ↓
3. 遍历物品，调用addItem()存入背包
       ↓
4. 关闭接近弹窗
       ↓
5. 显示搜刮结果界面
       ↓
6. 用户确认
       ↓
7. 返回地图继续探索
```

### 9.4 停止探索流程

```
1. 用户点击"停止探索"
       ↓
2. 停止所有地理围栏监控
       ↓
3. 清空POI列表
       ↓
4. MapTabView自动清除POI标记
       ↓
5. 计算行走奖励
       ↓
6. 显示探索结果（行走奖励 + POI搜刮汇总）
```

---

## 十、与现有代码的整合

### 10.1 需要修改的文件

| 文件 | 修改内容 |
|-----|---------|
| ExplorationManager.swift | 添加POI列表、围栏管理、弹窗状态 |
| MapTabView.swift | 添加POI标记显示、弹窗呈现 |

### 10.2 需要新建的文件

| 文件 | 职责 |
|-----|------|
| POISearchManager.swift | MapKit POI搜索封装 |
| POIProximityPopup.swift | 接近POI时的弹窗视图 |
| ScavengeResultView.swift | 搜刮结果展示视图 |

### 10.3 可复用的组件

| 组件 | 复用方式 |
|-----|---------|
| InventoryManager | 直接调用addItem()方法 |
| itemDefinitions | 作为物品池使用 |
| RewardGenerator | 可参考其随机逻辑 |

---

## 十一、验收标准

完成开发后，需要验证以下功能：

| 序号 | 验收项 | 预期结果 |
|-----|-------|---------|
| 1 | 点击开始探索 | 地图上显示附近POI标记 |
| 2 | POI标记 | 不同类型显示不同图标 |
| 3 | 走到POI附近 | 50米内弹出搜刮提示 |
| 4 | 点击立即搜刮 | 显示获得的物品列表 |
| 5 | 确认搜刮结果 | 物品存入背包 |
| 6 | 查看背包 | 能看到刚搜刮的物品 |
| 7 | 停止探索 | POI标记全部消失 |

---

## 十二、后续开发（不在Day22范围）

以下功能留到后续开发：

| 功能 | 说明 |
|-----|------|
| 多人密度机制 | 根据附近玩家数量调整POI显示数量 |
| POI隐藏机制 | 100米内才显示POI，增加探索感 |
| 冷却机制 | 搜刮后4小时不能再次搜刮 |
| POI类型关联 | 超市给食物、医院给药品 |
| 玩家位置上报 | 用于多人密度计算 |

---

*Day22 POI搜刮系统实现方案 v1.0*
*聚焦原理讲解，不含具体代码*
